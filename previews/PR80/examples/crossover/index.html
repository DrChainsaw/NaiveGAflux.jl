<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Crossover Operations · NaiveGAflux</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">NaiveGAflux</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../quicktutorial/">Quick Tutorial</a></li><li><span class="tocitem">AutoFlux</span><ul><li><a class="tocitem" href="../../autoflux/">AutoFlux</a></li><li><a class="tocitem" href="../../autoflux/reference/reference/">AutoFlux API Reference</a></li></ul></li><li><span class="tocitem">Components</span><ul><li><a class="tocitem" href="../searchspace/">Search Spaces</a></li><li><a class="tocitem" href="../mutation/">Mutation Operations</a></li><li class="is-active"><a class="tocitem" href>Crossover Operations</a></li><li><a class="tocitem" href="../fitness/">Fitness Functions</a></li><li><a class="tocitem" href="../candidate/">Candidate Utilities</a></li><li><a class="tocitem" href="../evolution/">Evolution Strategies</a></li><li><a class="tocitem" href="../iteratormaps/">Iterator Maps</a></li><li><a class="tocitem" href="../iterators/">Iterators</a></li></ul></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="../../reference/searchspace/">Search Spaces</a></li><li><a class="tocitem" href="../../reference/mutation/">Mutation Operations</a></li><li><a class="tocitem" href="../../reference/crossover/">Crossover Operations</a></li><li><a class="tocitem" href="../../reference/fitness/">Fitness Functions</a></li><li><a class="tocitem" href="../../reference/candidate/">Candidate Utilities</a></li><li><a class="tocitem" href="../../reference/evolution/">Evolution Strategies</a></li><li><a class="tocitem" href="../../reference/batchsize/">Batch Size Utilities</a></li><li><a class="tocitem" href="../../reference/iteratormaps/">Iterator Maps</a></li><li><a class="tocitem" href="../../reference/iterators/">Iterators</a></li><li><a class="tocitem" href="../../reference/utils/">Misc. Utilities</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Components</a></li><li class="is-active"><a href>Crossover Operations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Crossover Operations</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/DrChainsaw/NaiveGAflux.jl/blob/master/test/examples/crossover.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Crossover-Operations"><a class="docs-heading-anchor" href="#Crossover-Operations">Crossover Operations</a><a id="Crossover-Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Crossover-Operations" title="Permalink"></a></h1><p>Crossover is the way two candidates are combined to create new candidates. In NaiveGAflux crossover always maps two candidates into two new candidates. Just as for mutation, NaiveGAflux does this while preserving (to whatever extent possible) the parameters and alignment between layers of the combined models.</p><p>Crossover operations might not seem to make much sense when using parameter inheritance (i.e the concept that children retain the parameters of their parents). Randomly combining layers from two very different models will most likely not result in a well performing model. There are however a few potentially redeeming effects:</p><ul><li>Early in the evolution process parameters are not yet well fitted and inheriting parameters is not worse than random initialization</li><li>A mature population on the other hand will consist mostly of models which are close relatives and therefore have somewhat similar weights.</li></ul><p>Whether these effects actually make crossover a genuinely useful operation when evolving neural networks is not yet proven though. For now it is perhaps best to view the crossover operations as being provided mostly for the sake of completeness.</p><p>The following basic crossover operations are currently supported:</p><ol><li>Swap segments between two models using <a href="../../reference/crossover/#NaiveGAflux.CrossoverSwap"><code>CrossoverSwap</code></a>.</li><li>Swap optimizers between two candidates using <a href="../../reference/crossover/#NaiveGAflux.OptimizerCrossover"><code>OptimizerCrossover</code></a>.</li><li>Swap learning rate between two candidates using <a href="../../reference/crossover/#NaiveGAflux.LearningRateCrossover"><code>LearningRateCrossover</code></a>.</li></ol><p>Most of the mutation utilities also work with crossover operations. Here are a few examples:</p><p>Start by creating a model to play with.</p><pre><code class="language-julia hljs">invertex = denseinputvertex(&quot;A.in&quot;, 3)
layer1 = fluxvertex(&quot;A.l1&quot;, Dense(nout(invertex), 4), invertex; layerfun=ActivationContribution)
layer2 = fluxvertex(&quot;A.l2&quot;, Dense(nout(layer1), 5), layer1; layerfun=ActivationContribution)
layer3 = fluxvertex(&quot;A.l3&quot;, Dense(nout(layer2), 3), layer2; layerfun=ActivationContribution)
layer4 = fluxvertex(&quot;A.l4&quot;, Dense(nout(layer3), 2), layer3; layerfun=ActivationContribution)
modelA = CompGraph(invertex, layer4)</code></pre><p>Create an exact copy to show how parameter alignment is preserved. Prefix names with B so we can show that something actually happened.</p><pre><code class="language-julia hljs">import Functors
modelB = Functors.fmap(x -&gt; x isa String ? replace(x, r&quot;^A.\.*&quot; =&gt; &quot;B.&quot;) : x, modelA)

indata = reshape(collect(Float32, 1:3*2), 3,2)
@test modelA(indata) == modelB(indata)

@test name.(vertices(modelA)) == [&quot;A.in&quot;, &quot;A.l1&quot;, &quot;A.l2&quot;, &quot;A.l3&quot;, &quot;A.l4&quot;]
@test name.(vertices(modelB)) == [&quot;B.in&quot;, &quot;B.l1&quot;, &quot;B.l2&quot;, &quot;B.l3&quot;, &quot;B.l4&quot;]</code></pre><p><a href="../../reference/crossover/#NaiveGAflux.CrossoverSwap"><code>CrossoverSwap</code></a> takes ones vertex from each graph as input and swaps a random segment from each graph. By default it tries to make segments as similar as possible</p><pre><code class="language-julia hljs">swapsame = CrossoverSwap()

swapA = vertices(modelA)[4]
swapB = vertices(modelB)[4]
newA, newB = swapsame((swapA, swapB))</code></pre><p>It returns vertices of a new graph to be compatible with mutation utilities. Parent models are not modified.</p><pre><code class="language-julia hljs">@test newA ∉ vertices(modelA)
@test newB ∉ vertices(modelB)</code></pre><p>The function <code>regraph</code> is an internal utility which should not be needed in normal use cases, but here we use it to make comparison easier.</p><pre><code class="language-julia hljs">modelAnew = NaiveGAflux.regraph(newA)
modelBnew = NaiveGAflux.regraph(newB)

@test name.(vertices(modelAnew)) == [&quot;A.in&quot;, &quot;A.l1&quot;, &quot;B.l2&quot;, &quot;B.l3&quot;, &quot;A.l4&quot;]
@test name.(vertices(modelBnew)) == [&quot;B.in&quot;, &quot;B.l1&quot;, &quot;A.l2&quot;, &quot;A.l3&quot;, &quot;B.l4&quot;]

@test modelA(indata) == modelB(indata) == modelAnew(indata) == modelBnew(indata)</code></pre><p>Deviation parameter will randomly make segments unequal.</p><pre><code class="language-julia hljs">swapdeviation = CrossoverSwap(0.5)
modelAnew2, modelBnew2 = NaiveGAflux.regraph.(swapdeviation((swapA, swapB)))

@test name.(vertices(modelAnew2)) == [&quot;A.in&quot;, &quot;A.l1&quot;, &quot;A.l2&quot;, &quot;B.l1&quot;, &quot;B.l2&quot;, &quot;B.l3&quot;, &quot;A.l4&quot;]
@test name.(vertices(modelBnew2)) == [&quot;B.in&quot;, &quot;A.l3&quot;, &quot;B.l4&quot;]</code></pre><p><a href="../../reference/crossover/#NaiveGAflux.VertexCrossover"><code>VertexCrossover</code></a> applies the wrapped crossover operation to all vertices in a <code>CompGraph</code> and is the main API for doing crossover. It in addtion, it selects compatible pairs for us (i.e <code>swapA</code> and <code>swapB</code> above). It also takes an optional deviation parameter which is used when pairing.</p><pre><code class="language-julia hljs">crossoverall = VertexCrossover(swapdeviation, 0.5)

modelAnew3, modelBnew3 = crossoverall((modelA, modelB))</code></pre><p>I guess things got swapped back and forth so many times not much changed in the end.</p><pre><code class="language-julia hljs">@test name.(vertices(modelAnew3)) == [&quot;A.in&quot;, &quot;A.l2&quot;, &quot;A.l4&quot;]
@test name.(vertices(modelBnew3)) ==  [&quot;B.in&quot;, &quot;B.l3&quot;, &quot;B.l1&quot;, &quot;B.l2&quot;, &quot;A.l1&quot;, &quot;A.l3&quot;, &quot;B.l4&quot;]</code></pre><p>As advertised above, crossovers interop with most mutation utilities, just remember that input is a tuple for things which require a callback. Perform the swapping operation with a 30% probability for each valid vertex pair and log which vertices are being swapped.</p><pre><code class="language-julia hljs">crossoversome = VertexCrossover(
                    MutationProbability(
                        LogMutation(
                            ((v1,v2),) -&gt; &quot;Swap $(name(v1)) and $(name(v2))&quot;,
                            swapdeviation),
                    0.3)
                )

@test_logs( (:info, &quot;Swap A.l1 and B.l1&quot;),
            (:info, &quot;Swap A.l2 and B.l2&quot;),
            crossoversome((modelA, modelB)))</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../mutation/">« Mutation Operations</a><a class="docs-footer-nextpage" href="../fitness/">Fitness Functions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.19 on <span class="colophon-date" title="Wednesday 8 June 2022 22:59">Wednesday 8 June 2022</span>. Using Julia version 1.6.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
