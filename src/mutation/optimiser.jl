"""
    struct OptimiserMutation{F} <: AbstractMutation{Optimisers.AbstractRule}
    OptimiserMutation(optfun)
    OptimiserMutation(os::Union{Tuple, <:AbstractArray})

Mutatates optimisers not wrapped in `ShieldedOpt` through `optfun`.

Invoked recursively for `Optimisers.OptimiserChain`s.
"""
struct OptimiserMutation{F} <: AbstractMutation{Optimisers.AbstractRule}
    optfun::F
end
OptimiserMutation(os::Union{Tuple, <:AbstractArray}, rng=rng_default) = OptimiserMutation(o -> rand(rng, os)(learningrate(o)))

"""
    LearningRateMutation(rng=rng_default)

Return an `OptimiserMutation` which mutates the learning rate of optimisers.
"""
LearningRateMutation(rng=rng_default) = OptimiserMutation(o -> nudgelr(o, rng))

(m::OptimiserMutation)(opt::Optimisers.OptimiserChain) = Optimisers.OptimiserChain(m.(opt.opts))
(m::OptimiserMutation)(o::ShieldedOpt) = o;
(m::OptimiserMutation)(o::ImplicitOpt) = ImplicitOpt(m(o.rule))
(m::OptimiserMutation)(o::Optimisers.AbstractRule) = m.optfun(o)


nudgelr(o, rng=rng_default) = setlearningrate(o, nudgelr(learningrate(o), rng))
nudgelr(lr::T, rng=rng_default) where T <: Number = clamp(lr + (rand(rng, T) - oftype(lr, 0.5)) * lr * oftype(lr, 0.3), oftype(lr, 1e-6), oftype(lr, 1.0))

learningrate(o::Optimisers.OptimiserChain) = prod(learningrate.(o.opts))
learningrate(o::ShieldedOpt) = learningrate(o.rule)
learningrate(o::ImplicitOpt) = learningrate(o.rule)
learningrate(o) = o.eta

newlr(o, lrf = nudgelr) = setlearningrate(o, lrf(learningrate(o)))
setlearningrate(o::ImplicitOpt, lr) = setlearningrate(o.rule, lr)
setlearningrate(o, lr) = @set o.eta = lr

"""
    AddOptimiserMutation{F} <: AbstractMutation{Optimisers.AbstractRule}

Adds optimiser generated by `optgen(os)` to the set of optimisers where `os` is the existing set.

An attempt to merge optimisers of the same type is made using `mergeopts`.
"""
struct AddOptimiserMutation{F} <: AbstractMutation{Optimisers.AbstractRule}
    optgen::F
end
(m::AddOptimiserMutation)(o::ShieldedOpt) = o;
(m::AddOptimiserMutation)(o::ImplicitOpt) = ImplicitOpt(m(o.rule))
(m::AddOptimiserMutation)(o::Optimisers.AbstractRule) = m(Optimisers.OptimiserChain(o))
function (m::AddOptimiserMutation)(opt::Optimisers.OptimiserChain)
    newopt = m.optgen(opt)
    return Optimisers.OptimiserChain(mergeopts(typeof(newopt), newopt, opt.opts...))
end
