@testset "ParSpace example" begin
    # Set seed of default random number generator for reproduceable results
    using NaiveGAflux, Random
    Random.seed!(NaiveGAflux.rng_default, 123)

    ps1d = ParSpace([2,4,6,10])

    # Draw from the search space
    @test ps1d() == 2
    @test ps1d() == 6

    # Possible to supply another rng than the default one
    @test ps1d(MersenneTwister(0)) == 2

    # Can be of any dimension and type
    ps2d = ParSpace(["1","2","3"], ["4","5","6","7"])

    @test typeof(ps1d) == ParSpace{1, Int64}
    @test typeof(ps2d) == ParSpace{2, String}

    @test ps2d() == ("3", "6")
end

@testset "ConvSpace example" begin
    Random.seed!(NaiveGAflux.rng_default, 1)

    outsizes = 4:32
    kernelsizes = 3:9
    cs = ConvSpace2D(BaseLayerSpace(outsizes, [relu, elu, selu]), kernelsizes)

    @test typeof(cs) == ConvSpace{2}

    inputsize = 16
    convlayer = cs(inputsize)

    @test string(convlayer) == "Conv((5, 4), 16=>18, NNlib.elu)"
end

@testset "ArchSpace example" begin
    Random.seed!(NaiveGAflux.rng_default, 666)

    # VertexSpace creates a MutableVertex of layers generated by the wrapped search space
    cs = VertexSpace(ConvSpace2D(BaseLayerSpace(8:256, [identity, relu, elu]), 3:5))
    bs = VertexSpace(BatchNormSpace([identity, relu]))

    # Block of conv->bn and bn-conv respectively.
    # Need to make sure there is always at least one SizeAbsorb layer to make fork and res below play nice
    csbs = ListArchSpace(cs ,bs)
    bscs = ListArchSpace(bs, cs)

    # Randomly generate a conv-block:
    cblock = ArchSpace(ParSpace1D(cs, csbs, bscs))

    # Generate between 1 and 5 layers from csbs
    rep = RepeatArchSpace(cblock, 1:5)

    # Generate between 2 and 4 parallel paths joined by concatenation (inception like-blocks) from rep
    fork = ForkArchSpace(rep, 2:4)

    # Generate a residual connection around what is generated by rep
    res = ResidualArchSpace(rep)

    # ... and a residual fork
    resfork = ResidualArchSpace(fork)

    # Pick one of the above randomly...
    repforkres = ArchSpace(ParSpace1D(rep, fork, res, resfork))

    # ...1 to 3 times
    blocks = RepeatArchSpace(repforkres, 1:3)

    # End each block with subsamping through maxpooling
    ms = VertexSpace(MaxPoolSpace(PoolSpace2D([2])))
    reduction = ListArchSpace(blocks, ms)

    # And lets do 2 to 4 reductions
    featureextract = RepeatArchSpace(reduction, 2:4)

    # Add 1 to 3 dense layers as outputs
    dense = VertexSpace(DenseSpace(BaseLayerSpace(16:512, [relu, selu])))
    drep = RepeatArchSpace(dense, 0:2)
    # Last layer has fixed output size depending on number of labels
    dout=VertexSpace(DenseSpace(BaseLayerSpace(10, identity)))
    output = ListArchSpace(drep, dout)

    # Aaaand lets glue it together: Feature extracting conv+bn layers -> global pooling -> dense layers
    archspace = ListArchSpace(featureextract, GpVertex2D(), output)

    # Input is 3 channel image
    inputshape = inputvertex("input", 3, FluxConv{2}())

    # Sample one architecture from the search space
    graph1 = CompGraph(inputshape, archspace(inputshape))
    @test nv(graph1) == 123

    # And one more...
    graph2 = CompGraph(inputshape, archspace(inputshape))
    @test nv(graph2) == 75
end
